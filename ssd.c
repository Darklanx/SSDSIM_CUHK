/*****************************************************************************************************************************
This project was supported by the National Basic Research 973 Program of China under Grant No.2011CB302301
Huazhong University of Science and Technology (HUST)   Wuhan National Laboratory for Optoelectronics

FileName�� ssd.c
Author: Hu Yang		Version: 2.1	Date:2011/12/02
Description: 

History:
<contributor>     <time>        <version>       <desc>                   <e-mail>
Yang Hu	        2009/09/25	      1.0		    Creat SSDsim       yanghu@foxmail.com
                2010/05/01        2.x           Change 
Zhiming Zhu     2011/07/01        2.0           Change               812839842@qq.com
Shuangwu Zhang  2011/11/01        2.1           Change               820876427@qq.com
Chao Ren        2011/07/01        2.0           Change               529517386@qq.com
Hao Luo         2011/01/01        2.0           Change               luohao135680@gmail.com
*****************************************************************************************************************************/

#include "ssd.h"
#define min(x, y) (((x) < (y)) ? (x) : (y))
#define max(x, y) (((x) > (y)) ? (x) : (y))
void request_response_flush(struct ssd_info *ssd) {
    FILE *read_response_file = ssd->read_response_file;
    ssd->request_response_current = ssd->request_response_head;
    FILE *write_response_file = ssd->write_response_file;
    while (ssd->request_response_count != 0) {
        struct request *req = ssd->request_response_current;

        //printf("ope: %u\n", req->operation);
        //printf("time: %lld\n", req->begin_time);
        if (req->operation == 1) { // read
            fprintf(read_response_file, "%lld, READ, %lld\n", req->begin_time, req->response_time);
        } else if (req->operation == 0) { // write
            fprintf(write_response_file, "%lld, WRITE, %lld\n", req->begin_time, req->response_time);
            //printf("%lld\n", req->begin_time);
        }
        ssd->request_response_current = ssd->request_response_current->next_node;
        ssd->request_response_count -= 1;
    }
    fflush(read_response_file);
    fflush(write_response_file);
    ssd->request_response_current = ssd->request_response_head;
}
void free_request_response(struct ssd_info *ssd) {
    ssd->request_response_current = ssd->request_response_head;
    int i = 0;
    while (ssd->request_response_current != NULL) {
        struct request *req = ssd->request_response_current;
        ssd->request_response_current = ssd->request_response_current->next_node;
        free(req);
    }
}
int main(int argc, char *argv[]) {
    unsigned int i, j, k;
    struct ssd_info *ssd;

#ifdef DEBUG
    printf("enter main\n");
#endif

    ssd = (struct ssd_info *)malloc(sizeof(struct ssd_info));
    alloc_assert(ssd, "ssd");
    memset(ssd, 0, sizeof(struct ssd_info));

    if (argc <= 4)
        ssd = initiation(ssd, argv[1], argv[2], argv[3]);
    else {
        printf("ERROR!\n");
        return 1;
    }

    make_aged(ssd);
    if (ssd->parameter->initial_valid == 1) {
        insert_initial_valid(ssd);
    }

    // it seems that pre process page, finds the read in trace file and try to program the ssd based on the future read
    pre_process_page(ssd);

    for (i = 0; i < ssd->parameter->channel_number; i++) {
        for (j = 0; j < ssd->parameter->die_chip; j++) {
            for (k = 0; k < ssd->parameter->plane_die; k++) {
                printf("%d,0,%d,%d:  %5d\n", i, j, k, ssd->channel_head[i].chip_head[0].die_head[j].plane_head[k].free_page);
            }
        }
    }
    fprintf(ssd->outputfile, "\t\t\t\t\t\t\t\t\tOUTPUT\n");
    fprintf(ssd->outputfile, "****************** TRACE INFO ******************\n");

    ssd = simulate(ssd);
    statistic_output(ssd);
    /*	free_all_node(ssd);*/
    free_request_response(ssd);
    printf("\n");
    printf("the simulation is completed!\n");
    //fflush(stdout);
    return 1;
    /* 	_CrtDumpMemoryLeaks(); */
}

struct ssd_info *simulate(struct ssd_info *ssd) {

    int time_counter = 0;
    int flag = 1, flag1 = 0;
    double output_step = 0;
    unsigned int a = 0, b = 0;
    //errno_t err;

    printf("\n");
    printf("begin simulating.......................\n");
    printf("\n");
    printf("\n");
    printf("   ^o^    OK, please wait a moment, and enjoy music and coffee   ^o^    \n");

    ssd->tracefile = fopen(ssd->tracefilename, "r");
    if (ssd->tracefile == NULL) {
        printf("the trace file can't open\n");
        return NULL;
    }

    fprintf(ssd->outputfile, "app_id      arrive           lsn     size ope     begin time    response time    process time\n");
    fflush(ssd->outputfile);

    int i = 0;

    while (flag != 100) {

        flag = get_requests(ssd);

        if (flag == 1) {
            // has dram buffer
            if (ssd->parameter->dram_capacity != 0) {
                //printf("\nBuffer\n");
                buffer_management(ssd);
                distribute(ssd);

            } else {
                //printf("\nNo Buffer\n");
                no_buffer_distribute(ssd);
            }
        }
        process(ssd);

        trace_output(ssd);
        if (ssd->request_response_head->operation != 0) {
            exit(-1);
        }
        int64_t threshold = ssd->parameter->pad_amount;
        //printf("threshold: %lld\n", threshold);
        if (ssd->write_avg >= threshold) {
            //printf("larger\n");
            ssd->write_avg_pad += (double)ssd->write_avg / threshold;
            ssd->write_avg = ssd->write_avg % threshold;
        }
        if (ssd->read_avg >= threshold) {
            ssd->read_avg_pad += (double)ssd->read_avg / threshold;
            ssd->read_avg = ssd->read_avg % threshold;
        }

        if (flag == 0 && ssd->request_queue == NULL) {
            flag = 100;
        }
    }

    fclose(ssd->tracefile);
    return ssd;
}

/********    get_request    ******************************************************
*	1.get requests that arrived already
*	2.add those request node to ssd->reuqest_queue
*	return	0: reach the end of the trace
*			-1: no request has been added
*			1: add one request to list
********************************************************************************/
int count_request
    = 0;
int get_requests(struct ssd_info *ssd) {

    char buffer[200];
    unsigned int lsn = 0;
    //int64_t lsn = 0;

    int device = 0, size, ope, large_lsn, i = 0, j = 0;
    struct request *request1;
    int flag = 1;
    long filepoint;
    //int64_t time_tt = MAX_INT64; // NARGES originally it was 0, I changed to +inf, because after reaching to the end of file, it doesn't proceed to the nearest event
    unsigned long long time_tt = MAX_INT64;
    //int64_t nearest_event_time;
    unsigned long long nearest_event_time;

#ifdef DEBUG
    printf("TIP enter get_requests,  current time:%lld\n", ssd->current_time);
#endif

    // Narges this part has not tested yet
    //if(feof(ssd->tracefile))
    //	return 0;
    if (feof(ssd->tracefile)) {
        nearest_event_time = find_nearest_event(ssd);
        ssd->current_time = nearest_event_time;

        return 0;
    }

    filepoint = ftell(ssd->tracefile);
    sprintf(buffer, ""); // NARGES 01252015
    fgets(buffer, 200, ssd->tracefile);

    // NARGES
    int io_num = 1;
#ifdef UMASS

    static int counter = 0;
    counter++;

    // UMASS format: IO # , Arrival Time (ns) , Device # , File Descriptor # , Access Type , Offset , Length
    int file_desc = 0;
    char type[6];

    //sscanf(buffer, "%d %lld %d %d %s %d %d", &io_num, &time_tt, &device, &file_desc, &type, &lsn, &size);

    for (int i = 0; i < 200; i++) {
        if (buffer[i] == ',') {
            buffer[i] = ' ';
        }
    }
    //Timestamp,Hostname,DiskNumber,Type,Offset,Size,ResponseTime
    char dump[10];
    int dump2;
    int64_t offset;
    int dump3;
    sscanf(buffer, "%d %lld %s %d %s %lld %d %d", &io_num, &time_tt, &dump, &dump2, &type, &offset, &size, &dump3);

    if (feof(ssd->tracefile)) {
        //printf("EOF\n");
        request1 = NULL;
        return 0;
    }

    if (counter % 1000000 == 0) {
        printf("%d\n", counter);
    }
    //printf("%lld\n", time_tt);

    //printf("%llu\n", time_tt);
    //printf("%lf\n", ssd->time_scale);
    large_lsn = (int)((ssd->parameter->subpage_page * ssd->parameter->page_block * ssd->parameter->block_plane * ssd->parameter->plane_die * ssd->parameter->die_chip * ssd->parameter->chip_num) * (1 - ssd->parameter->overprovide));
    lsn = (unsigned int)(offset / (ssd->parameter->subpage_capacity) % large_lsn);
    //size /= 512;
    //printf("lsn: %d\n", lsn);
    /*
    if (lsn * 4 * 1024 != offset) {
        printf("ERRRRR\n");
        exit(-1);
    }
    */

    //sscanf(buffer, "%d %lld %d %d %s %d %d", &io_num, &time_tt, &device, &file_desc, &type, &lsn, &size);
    //printf("%s\n", buffer);
    //printf("It's: %lld %s %d %s %d %d %d\n", time_tt, dump, dump2, type, lsn, size, dump3);
    //printf("%d\n", counter);

    //printf("%f\n", f_time);
    //time_tt = (int64_t)(f_time * 1000000);
    //printf("%lld\n", time_tt);
    if (strcasecmp(type, "Read") == 0 || strcasecmp(type, "r") == 0) {
        ope = 1;
    } else {
        ope = 0;
    }
#else
    sscanf(buffer, "%lld %d %d %d %d", &time_tt, &device, &lsn, &size, &ope);
#endif

    // end NARGES

    if ((device < 0) && (lsn < 0) && (size < 0) && (ope < 0)) {
        return 100;
    }

    //lsn = lsn % large_lsn;
    if (lsn < ssd->min_lsn)
        ssd->min_lsn = lsn;
    if (lsn > ssd->max_lsn)
        ssd->max_lsn = lsn;
    if (lsn < 0) {

        printf("lsn < 0, lsn: %d\n", lsn);
        //exit(-1);
    }

    nearest_event_time = find_nearest_event(ssd);
    //printf("nearest event time: %lld\n", nearest_event_time);
    if (nearest_event_time == MAX_INT64) {
        if (ssd->current_time <= time_tt)
            ssd->current_time = time_tt;
        if (time_tt == (MAX_INT64)) {
            //printf("NOOO\n %lld\n", time_tt);
            return -1;
        }

    } else {
        if (nearest_event_time < time_tt) {

            fseek(ssd->tracefile, filepoint, 0);
            if (ssd->current_time <= nearest_event_time) {
                ssd->current_time = nearest_event_time;
            }
            return -1;
        } else {
            if (ssd->request_queue_length >= ssd->parameter->queue_length) {
                fseek(ssd->tracefile, filepoint, 0);
                /*
                if (ssd->request_queue_length == 32) {
                    exit(-1);
                }
                printf("dawn\n");
                */
                ssd->current_time = nearest_event_time;

                return -1;
            } else {

                if (ssd->current_time <= time_tt) // Narges: I added this condition
                    ssd->current_time = time_tt;

                if (time_tt == MAX_INT64)
                    return 0;
            }
        }
    }

    if (time_tt < 0) {
        printf("error!\n");
        while (1) {
        }
    }

    if (feof(ssd->tracefile)) {

        request1 = NULL;
        return 0;
    }

    request1 = (struct request *)malloc(sizeof(struct request));
    alloc_assert(request1, "request");
    memset(request1, 0, sizeof(struct request));

    request1->time = time_tt;
    request1->lsn = lsn;
    request1->size = size;
    request1->operation = ope;
    request1->begin_time = time_tt;
    request1->response_time = 0;
    request1->energy_consumption = 0;
    request1->next_node = NULL;
    request1->distri_flag = 0; // indicate whether this request has been distributed already
    request1->subs = NULL;
    request1->need_distr_flag = NULL;
    request1->complete_lsn_count = 0; //record the count of lsn served by buffer
    filepoint = ftell(ssd->tracefile); // set the file point

    if (ssd->request_queue == NULL) //The queue is empty
    {
        /*
        printf("req1: %lld\n", request1->begin_time);
        if (ssd-> request_response_head == NULL)
            ssd-> request_response_head = request1;
        printf("ope:%u\n", ssd-> request_response_head->operation);
        */
        ssd->request_queue = request1;
        ssd->request_tail = request1;
        ssd->request_queue_length++;
    } else {
        (ssd->request_tail)->next_node = request1;
        ssd->request_tail = request1;
        ssd->request_queue_length++;
    }

    if (request1->operation == 1) {
#ifdef DEBUG
        printf(" read request %lld\n", request1->time);
#endif
        ssd->ave_read_size = (ssd->ave_read_size * ssd->read_request_count + request1->size) / (ssd->read_request_count + 1);
    } else {
#ifdef DEBUG
        printf("write request %lld\n", request1->time);
#endif
        ssd->ave_write_size = (ssd->ave_write_size * ssd->write_request_count + request1->size) / (ssd->write_request_count + 1);
    }

    return 1;
}

struct ssd_info *buffer_management(struct ssd_info *ssd) {
    unsigned int j, lsn, lpn, last_lpn, first_lpn, index, complete_flag = 0, state, full_page;
    unsigned int flag = 0, need_distb_flag, lsn_flag, flag1 = 1, active_region_flag = 0;
    struct request *new_request;
    struct buffer_group *buffer_node, key;
    unsigned int mask = 0, offset1 = 0, offset2 = 0;

#ifdef DEBUG
    printf("enter buffer_management,  current time:%lld\n", ssd->current_time);
#endif
    ssd->dram->current_time = ssd->current_time;
    full_page = ~(0xffffffff << ssd->parameter->subpage_page);

    new_request = ssd->request_tail;
    lsn = new_request->lsn;
    lpn = new_request->lsn / ssd->parameter->subpage_page;

    last_lpn = (new_request->lsn + new_request->size - 1) / ssd->parameter->subpage_page;
    first_lpn = new_request->lsn / ssd->parameter->subpage_page;

    new_request->need_distr_flag = (unsigned int *)malloc(sizeof(unsigned int) * ((last_lpn - first_lpn + 1) * ssd->parameter->subpage_page / 32 + 1));
    alloc_assert(new_request->need_distr_flag, "new_request->need_distr_flag");
    memset(new_request->need_distr_flag, 0, sizeof(unsigned int) * ((last_lpn - first_lpn + 1) * ssd->parameter->subpage_page / 32 + 1));

    //printf("-----------------------\n lsn %d, lpn %d, first_lpn %d, last_lpn %d, subpage_page %d \n---------------\n\n", lsn, lpn, first_lpn, last_lpn, ssd->parameter->subpage_page);

    if (new_request->operation == READ) {
        while (lpn <= last_lpn) {
            need_distb_flag = full_page;
            key.group = lpn;
            buffer_node = (struct buffer_group *)avlTreeFind(ssd->dram->buffer, (TREE_NODE *)&key); // buffer node

            // Found in buffer
            while ((buffer_node != NULL) && (lsn < (lpn + 1) * ssd->parameter->subpage_page) && (lsn <= (new_request->lsn + new_request->size - 1))) {
                // stored shows which sectors are stored in the buffer

                lsn_flag = full_page;
                mask = 1 << (lsn % ssd->parameter->subpage_page);
                /*if(mask>31) //Narges commenting this part! 
				{
					printf("the subpage number is larger than 32!add some cases %d", mask);
					getchar(); 		   
				}
				else */
                if ((buffer_node->stored & mask) == mask) {
                    flag = 1;
                    lsn_flag = lsn_flag & (~mask);
                }

                if (flag == 1) {
                    if (ssd->dram->buffer->buffer_head != buffer_node) {
                        if (ssd->dram->buffer->buffer_tail == buffer_node) {
                            buffer_node->LRU_link_pre->LRU_link_next = NULL;
                            ssd->dram->buffer->buffer_tail = buffer_node->LRU_link_pre;
                        } else {
                            buffer_node->LRU_link_pre->LRU_link_next = buffer_node->LRU_link_next;
                            buffer_node->LRU_link_next->LRU_link_pre = buffer_node->LRU_link_pre;
                        }
                        buffer_node->LRU_link_next = ssd->dram->buffer->buffer_head;
                        ssd->dram->buffer->buffer_head->LRU_link_pre = buffer_node;
                        buffer_node->LRU_link_pre = NULL;
                        ssd->dram->buffer->buffer_head = buffer_node;
                    }
                    ssd->dram->buffer->read_hit++;
                    new_request->complete_lsn_count++;
                } else if (flag == 0) {
                    ssd->dram->buffer->read_miss_hit++;
                }

                need_distb_flag = need_distb_flag & lsn_flag;
                flag = 0;
                lsn++;
            }

            index = (lpn - first_lpn) / (32 / ssd->parameter->subpage_page);

            new_request->need_distr_flag[index] = new_request->need_distr_flag[index] | (need_distb_flag << (((lpn - first_lpn) % (32 / ssd->parameter->subpage_page)) * ssd->parameter->subpage_page));
            // need distr flag specify in a subpage need to be transfered or not. Here, this code collect information of one, two, ... pages in one array element.
            // e.g. if pagesize is 16, this code collect information of two pages in one array element

            lpn++;
        }
    } else if (new_request->operation == WRITE) {
        while (lpn <= last_lpn) {
            need_distb_flag = full_page;
            mask = ~(0xffffffff << (ssd->parameter->subpage_page));
            state = mask;

            if (lpn == first_lpn) {
                offset1 = ssd->parameter->subpage_page - ((lpn + 1) * ssd->parameter->subpage_page - new_request->lsn);
                state = state & (0xffffffff << offset1);
            }
            if (lpn == last_lpn) {
                offset2 = ssd->parameter->subpage_page - ((lpn + 1) * ssd->parameter->subpage_page - (new_request->lsn + new_request->size));
                state = state & (~(0xffffffff << offset2));
            }
            // state is which lsn needs to be written

            //if (new_request->io_num == 197)
            //	printf("TOE now we are inserting 197 into the buffer %lld \n", ssd->current_time);
            ssd = insert2buffer(ssd, lpn, state, NULL, new_request);

            lpn++;
        }
    }
    complete_flag = 1;
    for (j = 0; j <= (last_lpn - first_lpn + 1) * ssd->parameter->subpage_page / 32; j++) {
        if (new_request->need_distr_flag[j] != 0) {
            complete_flag = 0;
        }
    }

    // for writes the complete_flag is always 1 (I guess), it only depends on new_request->subs
    if ((complete_flag == 1) && (new_request->subs == NULL)) {

        new_request->begin_time = ssd->current_time;
        new_request->response_time = ssd->current_time + 1000;
    } else {
        //if (new_request->operation == WRITE)
        //printf(" this write request created sub requests %d \n", new_request->io_num);
    }

    return ssd;
}

unsigned int lpn2ppn(struct ssd_info *ssd, unsigned int lsn) {
    int lpn, ppn;
    struct entry *p_map = ssd->dram->map->map_entry;
#ifdef DEBUG
    printf("enter lpn2ppn,  current time:%lld\n", ssd->current_time);
#endif
    lpn = lsn / ssd->parameter->subpage_page; //lpn
    ppn = (p_map[lpn]).pn;
    return ppn;
}

struct ssd_info *distribute(struct ssd_info *ssd) {
    unsigned int start, end, first_lsn, last_lsn, lpn, flag = 0, flag_attached = 0, full_page;
    unsigned int j, k, sub_size;
    int i = 0;
    struct request *req;
    struct sub_request *sub;
    int *complt;

#ifdef DEBUG
    printf("enter distribute,  current time:%lld\n", ssd->current_time);
#endif
    full_page = ~(0xffffffff << ssd->parameter->subpage_page);

    req = ssd->request_tail;
    if (req->response_time != 0) {
        return ssd;
    }
    if (req->operation == WRITE) {
        return ssd;
    }

    if (req != NULL) {
        if (req->distri_flag == 0) {

            if (req->complete_lsn_count != ssd->request_tail->size) {
                first_lsn = req->lsn;
                last_lsn = first_lsn + req->size;
                complt = req->need_distr_flag; // which subpages need to be transfered
                start = first_lsn - first_lsn % ssd->parameter->subpage_page;
                end = (last_lsn / ssd->parameter->subpage_page + 1) * ssd->parameter->subpage_page;
                i = (end - start) / 32;

                while (i >= 0) {
                    for (j = 0; j < 32 / ssd->parameter->subpage_page; j++) {

                        k = (complt[((end - start) / 32 - i)] >> (ssd->parameter->subpage_page * j)) & full_page; // k: which subpages need to be transfered

                        if (k != 0) {
                            lpn = start / ssd->parameter->subpage_page + ((end - start) / 32 - i) * 32 / ssd->parameter->subpage_page + j;
                            sub_size = transfer_size(ssd, k, lpn, req);
                            if (sub_size == 0) {
                                continue;
                            } else {
                                sub = creat_sub_request(ssd, lpn, sub_size, 0, req, req->operation);
                            }
                        }
                    }
                    i = i - 1;
                }

            } else {
                req->begin_time = ssd->current_time;
                req->response_time = ssd->current_time + 1000;
            }
        }
    }
    return ssd;
}

void trace_output(struct ssd_info *ssd) {
    int flag = 1;
    int64_t start_time, end_time, wait_time;
    struct request *req, *pre_node;
    struct sub_request *sub, *tmp;

#ifdef DEBUG
    printf("enter trace_output,  current time:%lld\n", ssd->current_time);
#endif

    pre_node = NULL;
    req = ssd->request_queue;
    start_time = 0;
    end_time = 0;

    if (req == NULL)
        return;

    while (req != NULL) {

        sub = req->subs;
        flag = 1;
        start_time = 0;
        end_time = 0;
        wait_time = 0;

        if (req->response_time != 0) {
            printf("This should not be shown\n");
            if (req->response_time - req->begin_time == 0) {
                printf("the response time is 0?? \n");
                getchar();
            }

            if (req->operation == READ) {

                ssd->read_request_size += req->size;
                ssd->read_avg = ssd->read_avg + (req->response_time - req->time);

                ssd->read_request_count++;

            } else {

                ssd->write_request_size += req->size;
                ssd->write_avg = ssd->write_avg + (req->response_time - req->time);

                ssd->write_request_count++;
            }

            if (pre_node == NULL) {
                if (req->next_node == NULL) {
                    free(req->need_distr_flag);
                    req->need_distr_flag = NULL;
                    free(req);
                    req = NULL;
                    ssd->request_queue = NULL;
                    ssd->request_tail = NULL;
                    ssd->request_queue_length--;
                } else {
                    ssd->request_queue = req->next_node;
                    pre_node = req;
                    req = req->next_node;
                    free(pre_node->need_distr_flag);
                    pre_node->need_distr_flag = NULL;
                    free((void *)pre_node);
                    pre_node = NULL;
                    ssd->request_queue_length--;
                }
            } else {
                if (req->next_node == NULL) {
                    pre_node->next_node = NULL;
                    free(req->need_distr_flag);
                    req->need_distr_flag = NULL;
                    free(req);
                    req = NULL;
                    ssd->request_tail = pre_node;
                    ssd->request_queue_length--;
                } else {
                    pre_node->next_node = req->next_node;
                    free(req->need_distr_flag);
                    req->need_distr_flag = NULL;
                    free((void *)req);
                    req = pre_node->next_node;
                    ssd->request_queue_length--;
                }
            }
        } else {

            flag = 1;
            while (sub != NULL) {

                if (start_time == 0)
                    start_time = sub->begin_time;
                if (start_time > sub->begin_time)
                    start_time = sub->begin_time;
                if (end_time < sub->complete_time)
                    end_time = sub->complete_time;
                if (wait_time < sub->wait_time)
                    wait_time = sub->wait_time;

                if ((sub->current_state == SR_COMPLETE) || ((sub->next_state == SR_COMPLETE) && (sub->next_state_predict_time <= ssd->current_time))) // if any sub-request is not completed, the request is not completed
                {

                    sub = sub->next_subs;
                } else {

                    flag = 0;
                    break;
                }
            }

            if (flag == 1) {

                if (end_time - start_time == 0) {
                    printf("the response time is 0?? \n");
                    getchar();
                }
                // HANDLE OUTPUT RESPONSE TIME

                if (req->operation == READ) {

                    ssd->read_request_count++;
                    ssd->read_request_size += req->size;
                    ssd->read_avg = ssd->read_avg + (end_time - req->time);
                    //printf("t: %lld\n", end_time - start_time);
                    //req->response_time = end_time - req->time;

                } else {
                    ssd->write_request_count++;
                    ssd->write_request_size += req->size;
                    ssd->write_avg = ssd->write_avg + (end_time - req->time);
                    //printf("t: %lld\n", end_time - start_time);
                    //req->response_time = end_time - req->time;

                    struct sub_request *sr = req->subs;
                }
                // handle request_response
                ssd->request_response_current->response_time = end_time - req->time;
                ssd->request_response_current->operation = req->operation;
                ssd->request_response_current->begin_time = req->begin_time;
                ssd->request_response_current = ssd->request_response_current->next_node;
                ssd->request_response_count = ssd->request_response_count + 1;
                if (ssd->request_response_count == 999) {
                    request_response_flush(ssd);
                }
                while (req->subs != NULL) {
                    tmp = req->subs;
                    req->subs = tmp->next_subs;
                    if (tmp->update != NULL) {
                        free(tmp->update->location);
                        tmp->update->location = NULL;
                        free(tmp->update);
                        tmp->update = NULL;
                    }
                    free(tmp->location);
                    tmp->location = NULL;
                    free(tmp);
                    tmp = NULL;
                }

                if (pre_node == NULL) {
                    if (req->next_node == NULL) {
                        free(req->need_distr_flag);
                        req->need_distr_flag = NULL;
                        free(req);
                        req = NULL;
                        ssd->request_queue = NULL;
                        ssd->request_tail = NULL;
                        ssd->request_queue_length--;
                    } else {
                        ssd->request_queue = req->next_node;
                        pre_node = req;
                        req = req->next_node;
                        free(pre_node->need_distr_flag);
                        pre_node->need_distr_flag = NULL;
                        free(pre_node);
                        pre_node = NULL;
                        ssd->request_queue_length--;
                    }
                } else {
                    if (req->next_node == NULL) {
                        pre_node->next_node = NULL;
                        free(req->need_distr_flag);
                        req->need_distr_flag = NULL;
                        free(req);
                        req = NULL;
                        ssd->request_tail = pre_node;
                        ssd->request_queue_length--;
                    } else {
                        pre_node->next_node = req->next_node;
                        free(req->need_distr_flag);
                        req->need_distr_flag = NULL;
                        free(req);
                        req = pre_node->next_node;
                        ssd->request_queue_length--;
                    }
                }
            } else {
                pre_node = req;
                req = req->next_node;
            }
        }
    }
}

void statistic_output(struct ssd_info *ssd) {
    unsigned int lpn_count = 0, i, j, k, m, erase = 0, plane_erase = 0, chip_i;
    double gc_energy = 0.0;
#ifdef DEBUG
    printf("enter statistic_output,  current time:%lld\n", ssd->current_time);
#endif

    for (i = 0; i < ssd->parameter->channel_number; i++) {
        for (chip_i = 0; chip_i < ssd->parameter->chip_channel[i]; chip_i++) {

            for (j = 0; j < ssd->parameter->die_chip; j++) {
                for (k = 0; k < ssd->parameter->plane_die; k++) {
                    plane_erase = 0;
                    for (m = 0; m < ssd->parameter->block_plane; m++) {

                        if (ssd->channel_head[i].chip_head[0].die_head[j].plane_head[k].blk_head[m].erase_count > 0) {
                            erase = erase + ssd->channel_head[i].chip_head[0].die_head[j].plane_head[k].blk_head[m].erase_count;
                            plane_erase += ssd->channel_head[i].chip_head[0].die_head[j].plane_head[k].blk_head[m].erase_count;
                        }
                    }
                    fprintf(ssd->outputfile, "the %d channel, %d chip, %d die, %d plane has : %13d erase operations\n", i, chip_i, j, k, plane_erase);
                    fprintf(ssd->statisticfile, "the %d channel, %d chip, %d die, %d plane has : %13d erase operations\n", i, chip_i, j, k, plane_erase);
                }
            }
        }
    }

    fprintf(ssd->outputfile, "\n");
    fprintf(ssd->outputfile, "\n");
    fprintf(ssd->outputfile, "---------------------------statistic data of page-level erase --------------------------\n");
    fprintf(ssd->outputfile, "min lsn: %13d\n", ssd->min_lsn);
    fprintf(ssd->outputfile, "max lsn: %13d\n", ssd->max_lsn);
    fprintf(ssd->outputfile, "read count: %13d\n", ssd->read_count);
    fprintf(ssd->outputfile, "program count: %13d", ssd->program_count);
    fprintf(ssd->outputfile, "                        include the flash write count leaded by read requests\n");
    fprintf(ssd->outputfile, "the read operation leaded by un-covered update count: %13d\n", ssd->update_read_count);
    fprintf(ssd->outputfile, "erase count: %13d\n", ssd->erase_count);
    fprintf(ssd->outputfile, "direct erase count: %13d\n", ssd->direct_erase_count);
    fprintf(ssd->outputfile, "copy back count: %13d\n", ssd->copy_back_count);
    fprintf(ssd->outputfile, "multi-plane program count: %13d\n", ssd->m_plane_prog_count);
    fprintf(ssd->outputfile, "multi-plane read count: %13d\n", ssd->m_plane_read_count);
    fprintf(ssd->outputfile, "interleave write count: %13d\n", ssd->interleave_count);
    fprintf(ssd->outputfile, "interleave read count: %13d\n", ssd->interleave_read_count);
    fprintf(ssd->outputfile, "interleave two plane and one program count: %13d\n", ssd->inter_mplane_prog_count);
    fprintf(ssd->outputfile, "interleave two plane count: %13d\n", ssd->inter_mplane_count);
    fprintf(ssd->outputfile, "gc copy back count: %13d\n", ssd->gc_copy_back);
    fprintf(ssd->outputfile, "write flash count: %13d\n", ssd->write_flash_count);
    fprintf(ssd->outputfile, "interleave erase count: %13d\n", ssd->interleave_erase_count);
    fprintf(ssd->outputfile, "multiple plane erase count: %13d\n", ssd->mplane_erase_conut);
    fprintf(ssd->outputfile, "interleave multiple plane erase count: %13d\n", ssd->interleave_mplane_erase_count);
    fprintf(ssd->outputfile, "read request count: %13d\n", ssd->read_request_count);
    fprintf(ssd->outputfile, "write request count: %13d\n", ssd->write_request_count);
    fprintf(ssd->outputfile, "read request average size: %13f\n", ssd->ave_read_size);
    fprintf(ssd->outputfile, "write request average size: %13f\n", ssd->ave_write_size);

    if (ssd->read_request_count != 0) {
        //fprintf(ssd->outputfile, "read request average response time: %lld\n", ssd->read_avg / ssd->read_request_count);
        double read_avg_pad = (double)ssd->read_avg_pad / ssd->read_request_count;
        double floating = read_avg_pad - (long long)read_avg_pad;
        //printf("floating: %lf\n", floating);
        long long tmp = (long long)(floating * min(ssd->parameter->pad_amount, 100000));
        //printf("tmp: %lld\n", tmp);

        tmp *= max(1, ssd->parameter->pad_amount / 100000);
        //printf("tmp: %lld\n", tmp);
        fprintf(ssd->outputfile, "read request average response time: %lld%lld\n", (long long)read_avg_pad, tmp + ssd->read_avg / ssd->read_request_count);
    }
    if (ssd->write_request_count != 0) {
        //fprintf(ssd->outputfile, "write request average response time: %lld\n", ssd->write_avg / ssd->write_request_count);

        double write_avg_pad = (double)ssd->write_avg_pad / ssd->write_request_count;
        double floating = write_avg_pad - (long long)write_avg_pad;
        //printf("floating: %lf\n", floating);
        long long tmp = (long long)(floating * min(ssd->parameter->pad_amount, 100000));
        //printf("tmp: %lld\n", tmp);

        tmp *= max(1, ssd->parameter->pad_amount / 100000);
        //printf("tmp: %lld\n", tmp);
        fprintf(ssd->outputfile, "write request average response time: %lld%lld\n", (long long)write_avg_pad, tmp + ssd->write_avg / ssd->write_request_count);
    }
    fprintf(ssd->outputfile, "buffer read hits: %13d\n", ssd->dram->buffer->read_hit);
    fprintf(ssd->outputfile, "buffer read miss: %13d\n", ssd->dram->buffer->read_miss_hit);
    fprintf(ssd->outputfile, "buffer write hits: %13d\n", ssd->dram->buffer->write_hit);
    fprintf(ssd->outputfile, "buffer write miss: %13d\n", ssd->dram->buffer->write_miss_hit);
    fprintf(ssd->outputfile, "erase: %13d\n", erase);
    fflush(ssd->outputfile);

    fclose(ssd->outputfile);

    fprintf(ssd->statisticfile, "\n");
    fprintf(ssd->statisticfile, "\n");
    fprintf(ssd->statisticfile, "---------------------------statistic data---------------------------\n");
    fprintf(ssd->statisticfile, "min lsn: %13d\n", ssd->min_lsn);
    fprintf(ssd->statisticfile, "max lsn: %13d\n", ssd->max_lsn);
    fprintf(ssd->statisticfile, "read count: %13d\n", ssd->read_count);
    fprintf(ssd->statisticfile, "program count: %13d", ssd->program_count);
    fprintf(ssd->statisticfile, "                        include the flash write count leaded by read requests\n");
    fprintf(ssd->statisticfile, "the read operation leaded by un-covered update count: %13d\n", ssd->update_read_count);
    fprintf(ssd->statisticfile, "erase count: %13d\n", ssd->erase_count);
    fprintf(ssd->statisticfile, "direct erase count: %13d\n", ssd->direct_erase_count);
    fprintf(ssd->statisticfile, "copy back count: %13d\n", ssd->copy_back_count);
    fprintf(ssd->statisticfile, "multi-plane program count: %13d\n", ssd->m_plane_prog_count);
    fprintf(ssd->statisticfile, "multi-plane read count: %13d\n", ssd->m_plane_read_count);
    fprintf(ssd->statisticfile, "interleave count: %13d\n", ssd->interleave_count);
    fprintf(ssd->statisticfile, "interleave read count: %13d\n", ssd->interleave_read_count);
    fprintf(ssd->statisticfile, "interleave two plane and one program count: %13d\n", ssd->inter_mplane_prog_count);
    fprintf(ssd->statisticfile, "interleave two plane count: %13d\n", ssd->inter_mplane_count);
    fprintf(ssd->statisticfile, "gc copy back count: %13d\n", ssd->gc_copy_back);
    fprintf(ssd->statisticfile, "write flash count: %13d\n", ssd->write_flash_count);
    fprintf(ssd->statisticfile, "waste page count: %13d\n", ssd->waste_page_count);
    fprintf(ssd->statisticfile, "interleave erase count: %13d\n", ssd->interleave_erase_count);
    fprintf(ssd->statisticfile, "multiple plane erase count: %13d\n", ssd->mplane_erase_conut);
    fprintf(ssd->statisticfile, "interleave multiple plane erase count: %13d\n", ssd->interleave_mplane_erase_count);
    fprintf(ssd->statisticfile, "read request count: %13d\n", ssd->read_request_count);
    fprintf(ssd->statisticfile, "write request count: %13d\n", ssd->write_request_count);
    fprintf(ssd->statisticfile, "read request average size: %13f\n", ssd->ave_read_size);
    fprintf(ssd->statisticfile, "write request average size: %13f\n", ssd->ave_write_size);
    if (ssd->read_request_count != 0)
        fprintf(ssd->statisticfile, "read request average response time: %lld\n", ssd->read_avg / ssd->read_request_count);
    if (ssd->write_request_count != 0)
        fprintf(ssd->statisticfile, "write request average response time: %lld\n", ssd->write_avg / ssd->write_request_count);

    fprintf(ssd->statisticfile, "buffer read hits: %13d\n", ssd->dram->buffer->read_hit);
    fprintf(ssd->statisticfile, "buffer read miss: %13d\n", ssd->dram->buffer->read_miss_hit);
    fprintf(ssd->statisticfile, "buffer write hits: %13d\n", ssd->dram->buffer->write_hit);
    fprintf(ssd->statisticfile, "buffer write miss: %13d\n", ssd->dram->buffer->write_miss_hit);
    fprintf(ssd->statisticfile, "erase: %13d\n", erase);
    fprintf(ssd->statisticfile, "========================\n");

    fflush(ssd->statisticfile);

    fclose(ssd->statisticfile);

    request_response_flush(ssd);
    fclose(ssd->read_response_file);
    fclose(ssd->write_response_file);
}
unsigned int size(unsigned int stored) {
    unsigned int i, total = 0, mask = 0x80000000;

#ifdef DEBUG
    printf("enter size\n");
#endif
    for (i = 1; i <= 32; i++) {
        if (stored & mask)
            total++;
        stored <<= 1;
    }
#ifdef DEBUG
    printf("leave size\n");
#endif
    return total;
}

unsigned int transfer_size(struct ssd_info *ssd, int need_distribute, unsigned int lpn, struct request *req) {
    unsigned int first_lpn, last_lpn, state, trans_size;
    unsigned int mask = 0, offset1 = 0, offset2 = 0;

    first_lpn = req->lsn / ssd->parameter->subpage_page;
    last_lpn = (req->lsn + req->size - 1) / ssd->parameter->subpage_page;

    mask = ~(0xffffffff << (ssd->parameter->subpage_page));
    state = mask;
    if (lpn == first_lpn) {
        offset1 = ssd->parameter->subpage_page - ((lpn + 1) * ssd->parameter->subpage_page - req->lsn);
        state = state & (0xffffffff << offset1);
    }
    if (lpn == last_lpn) {
        offset2 = ssd->parameter->subpage_page - ((lpn + 1) * ssd->parameter->subpage_page - (req->lsn + req->size));
        state = state & (~(0xffffffff << offset2));
    }

    trans_size = size(state & need_distribute);

    return trans_size;
}

int64_t find_nearest_event(struct ssd_info *ssd) {
    unsigned int i, j;
    int64_t time = MAX_INT64;
    int64_t time1 = MAX_INT64;
    int64_t time2 = MAX_INT64;
    int64_t next_epoch_time = MAX_INT64;

    for (i = 0; i < ssd->parameter->channel_number; i++) {
        if (ssd->channel_head[i].next_state == CHANNEL_IDLE)
            if (time1 > ssd->channel_head[i].next_state_predict_time)
                if (ssd->channel_head[i].next_state_predict_time > ssd->current_time)
                    time1 = ssd->channel_head[i].next_state_predict_time;
        for (j = 0; j < ssd->parameter->chip_channel[i]; j++) {

            if ((ssd->channel_head[i].chip_head[j].next_state == CHIP_IDLE) || (ssd->channel_head[i].chip_head[j].next_state == CHIP_DATA_TRANSFER))
                if (time2 > ssd->channel_head[i].chip_head[j].next_state_predict_time)
                    if (ssd->channel_head[i].chip_head[j].next_state_predict_time > ssd->current_time)
                        time2 = ssd->channel_head[i].chip_head[j].next_state_predict_time;
        }
    }

    time = (time1 > time2) ? time2 : time1;

    return time;
}

void free_all_node(struct ssd_info *ssd) {
    unsigned int i, j, k, l, n;
    struct buffer_group *pt = NULL;
    struct direct_erase *erase_node = NULL;
    for (i = 0; i < ssd->parameter->channel_number; i++) {
        for (j = 0; j < ssd->parameter->chip_channel[0]; j++) {
            for (k = 0; k < ssd->parameter->die_chip; k++) {
                for (l = 0; l < ssd->parameter->plane_die; l++) {
                    for (n = 0; n < ssd->parameter->block_plane; n++) {
                        free(ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].blk_head[n].page_head);
                        ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].blk_head[n].page_head = NULL;
                    }
                    free(ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].blk_head);
                    ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].blk_head = NULL;
                    while (ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].erase_node != NULL) {
                        erase_node = ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].erase_node;
                        ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].erase_node = erase_node->next_node;
                        free(erase_node);
                        erase_node = NULL;
                    }
                }

                free(ssd->channel_head[i].chip_head[j].die_head[k].plane_head);
                ssd->channel_head[i].chip_head[j].die_head[k].plane_head = NULL;
            }
            free(ssd->channel_head[i].chip_head[j].die_head);
            ssd->channel_head[i].chip_head[j].die_head = NULL;
        }
        free(ssd->channel_head[i].chip_head);
        ssd->channel_head[i].chip_head = NULL;
    }
    free(ssd->channel_head);
    ssd->channel_head = NULL;

    avlTreeDestroy(ssd->dram->buffer);
    ssd->dram->buffer = NULL;

    free(ssd->dram->map->map_entry);
    ssd->dram->map->map_entry = NULL;
    free(ssd->dram->map);
    ssd->dram->map = NULL;
    free(ssd->dram);
    ssd->dram = NULL;
    free(ssd->parameter);
    ssd->parameter = NULL;

    free(ssd);
    ssd = NULL;
}

struct ssd_info *make_aged(struct ssd_info *ssd) {
    unsigned int i, j, k, l, m, n, ppn;
    int threshould, flag = 0;

    if (ssd->parameter->aged == 1) {

        threshould = (int)(ssd->parameter->block_plane * ssd->parameter->page_block * ssd->parameter->aged_ratio);
        for (i = 0; i < ssd->parameter->channel_number; i++)
            for (j = 0; j < ssd->parameter->chip_channel[i]; j++)
                for (k = 0; k < ssd->parameter->die_chip; k++)
                    for (l = 0; l < ssd->parameter->plane_die; l++) {
                        flag = 0;
                        for (m = 0; m < ssd->parameter->block_plane; m++) {
                            if (flag >= threshould) {
                                break;
                            }
                            for (n = 0; n < (ssd->parameter->page_block * ssd->parameter->aged_ratio + 1); n++) {
                                ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].blk_head[m].page_head[n].valid_state = 0;
                                ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].blk_head[m].page_head[n].free_state = 0;
                                ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].blk_head[m].page_head[n].lpn = 0;
                                ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].blk_head[m].free_page_num--;
                                ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].blk_head[m].invalid_page_num++;
                                ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].blk_head[m].last_write_page++;
                                ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].free_page--;
                                flag++;

                                ppn = find_ppn(ssd, i, j, k, l, m, n);
                            }
                        }
                    }
    } else {
        return ssd;
    }

    return ssd;
}

struct ssd_info *insert_initial_valid(struct ssd_info *ssd) {
    unsigned int i, j, k, l, m, n, ppn;
    int threshould, flag = 0;

    if (ssd->parameter->initial_valid == 1) {
        //srand(time(NULL));
        srand(0);
        unsigned int largest_lpn = (unsigned int)((ssd->parameter->chip_num * ssd->parameter->die_chip * ssd->parameter->plane_die * ssd->parameter->block_plane * ssd->parameter->page_block) * (1 - ssd->parameter->overprovide));

        int lpn = (rand() % largest_lpn);
        threshould = (int)(ssd->parameter->block_plane * ssd->parameter->page_block * ssd->parameter->valid_ratio);

        for (i = 0; i < ssd->parameter->channel_number; i++)
            for (j = 0; j < ssd->parameter->chip_channel[i]; j++)
                for (k = 0; k < ssd->parameter->die_chip; k++)
                    for (l = 0; l < ssd->parameter->plane_die; l++) {
                        flag = 0;
                        for (m = 0; m < ssd->parameter->block_plane; m++) {
                            if (flag >= threshould) {
                                break;
                            }
                            for (n = 0; n < (ssd->parameter->page_block * ssd->parameter->valid_ratio + 1); n++) {
                                ppn = find_ppn(ssd, i, j, k, l, m, n);
                                ssd->dram->map->map_entry[lpn].state = 0xffffffff;
                                ssd->dram->map->map_entry[lpn].pn = ppn;

                                ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].blk_head[m].page_head[n].valid_state = 1;
                                ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].blk_head[m].page_head[n].free_state = 0;
                                ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].blk_head[m].page_head[n].lpn = lpn;

                                ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].blk_head[m].free_page_num--;
                                ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].blk_head[m].last_write_page++;
                                ssd->channel_head[i].chip_head[j].die_head[k].plane_head[l].free_page--;
                                flag++;
                                // 偷懶寫法 有空補個hash table來判斷ㄅ 這邊是要避開重複的lpn
                                // 為啥c沒有map QQ
                                do {
                                    lpn = (rand() % largest_lpn);
                                } while (ssd->dram->map->map_entry[lpn].state == 0xffffffff);
                            }
                        }
                    }
    } else {
        return ssd;
    }

    return ssd;
}

struct ssd_info *no_buffer_distribute(struct ssd_info *ssd) {
    unsigned int lsn, lpn, last_lpn, first_lpn, complete_flag = 0, state;
    unsigned int flag = 0, flag1 = 1, active_region_flag = 0; //to indicate the lsn is hitted or not
    struct request *req = NULL;
    struct sub_request *sub = NULL, *sub_r = NULL, *update = NULL;
    struct local *loc = NULL;
    struct channel_info *p_ch = NULL;

    unsigned int mask = 0;
    unsigned int offset1 = 0, offset2 = 0;
    unsigned int sub_size = 0;
    unsigned int sub_state = 0;

    ssd->dram->current_time = ssd->current_time;
    req = ssd->request_tail;
    lsn = req->lsn;
    lpn = req->lsn / ssd->parameter->subpage_page;
    last_lpn = (req->lsn + req->size - 1) / ssd->parameter->subpage_page;
    first_lpn = req->lsn / ssd->parameter->subpage_page;

    if (req->operation == READ) {
        while (lpn <= last_lpn) {
            sub_state = (ssd->dram->map->map_entry[lpn].state & 0x7fffffff);
            sub_size = size(sub_state);
            sub = creat_sub_request(ssd, lpn, sub_size, sub_state, req, req->operation);

            lpn++;
        }
    } else if (req->operation == WRITE) {
        while (lpn <= last_lpn) {
            mask = ~(0xffffffff << (ssd->parameter->subpage_page));
            state = mask;
            if (lpn == first_lpn) {
                offset1 = ssd->parameter->subpage_page - ((lpn + 1) * ssd->parameter->subpage_page - req->lsn);
                state = state & (0xffffffff << offset1);
            }
            if (lpn == last_lpn) {
                offset2 = ssd->parameter->subpage_page - ((lpn + 1) * ssd->parameter->subpage_page - (req->lsn + req->size));
                state = state & (~(0xffffffff << offset2));
            }
            sub_size = size(state);

            sub = creat_sub_request(ssd, lpn, sub_size, state, req, req->operation);
            lpn++;
        }
    }

    return ssd;
}
int waiting_event(struct ssd_info *ssd) {
    int waiting_events = 0;
    int i, j;
    for (i = 0; i < ssd->parameter->channel_number; i++) {

        if (ssd->channel_head[i].next_state == CHANNEL_IDLE)
            if (ssd->channel_head[i].next_state_predict_time > ssd->current_time)
                waiting_events++;

        for (j = 0; j < ssd->parameter->chip_channel[i]; j++) {
            if ((ssd->channel_head[i].chip_head[j].next_state == CHIP_IDLE) || (ssd->channel_head[i].chip_head[j].next_state == CHIP_DATA_TRANSFER))
                if (ssd->channel_head[i].chip_head[j].next_state_predict_time > ssd->current_time) {
                    waiting_events++;
                }
        }
    }

    return waiting_events;
}
